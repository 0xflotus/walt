# Syntax Version 0.1

## ;

No semicolons. I couldn't think of a good reason for them.

## Module

Each file is assumed to be a module and is scoped as such, unless the `module` keyword is used to declare 1 or more
modules inside the file.

**module** _See: function_

`module` is an alias for `function` but is treated as a special Module declaration by the parser. This provides
the ability to define more than one module per file. Which is also available in wast.

```
// module and function keyword can omit an identifier
module () {
  // memory, table, imports, exports and module body are here
}

// Multiple modules can be declared in a single file
module bar() {
  // everything scoped to bar
}

// assertions, not part of any module code

// assert_return(...);
// assert_return(...);
```

These two are equivalent
* `module () {}` - empty module function
* ` ` -  empty file

They compile to:
* `(module)` - empty module

## Functions

Function declarations resemble ES5 functions. Functions with return values must be declared as such. A function not
returning a result can omit a return type.

```
// name can be omited, but the function may not be referenced
function() {
};

// named function
function foo() {
}

// return values
function bar(): i32 {
  x:f64 = 5.0
  return x
} //     ^  Type Error: return value of type i32 expected

// IIFE
(function (num): bool {
  return num % 2 !== 0
})(2)
```

## Exports, Imports

ES6-like imports and exports are supported. `default` keyword is not, there are not default exports in wast modules.

```
module foobar() {
  import log from 'console'

  global counter: i32 = 0

  export function count() {
    log(counter++)
  }
}
```

`import` statements are only allowed at the top of the module. `import` inside module body is a syntax error.

```
module notallowed() {
  global foo: bool = false
  import log from 'console'
  // ^ Syntax error
}
```

## Memory, Table

Memory and Table defined with by `memory` and `table` keyword. Values of each must be an arrays.

**Memory**

` mem: memory = [0, 128] // number of pages [min, max]`

**Table**

## Types

Native wasm modules are supported: `i32, i64, f32, f64`. With two additional types `bool` and `func`.

* `bool` is an alias for `i32` but is a strictly type checked.
* `func` is a function pointer. Function pointer cannot be cast to any other type.

**Type casting**

All type-casting must be explicit. No type casting is performed for you. Parser will throw an error on implicit conversions.

```
x: i32 = 0
y: f32 = 1

x = y;
// ^ Type Error: implicit conversion f32 to i32

x = y:i32
// Ok!

z: bool = 1
x = z
// ^ Type Error: implicit conversion bool to i32

// bool is alias for i32 but is type-checked for full type safety
x = z:i32
// Ok!

// function pointer cannot be converted
function (log: func) {
  x: i64 = func
  // ^ Type Error: cannot convert function to i64
  z: i64;
  z = log:i64;
  // ^ Type Error: cannot convert function to i64
}
```

```javascript

function fibonacci(num){
  var a = 1, b = 0, temp;

  while (num >= 0){
    temp = a;
    a = a + b;
    b = temp;
    num--;
  }

  return b;
}
```

```
function fibonacci(num: i64): i64 {
	a: i64 = 1
  b: i64 = 0
  temp: i64

	while (num >= 0) {
		temp = a
    a = a + b
    b = temp
    num--
  }

  return b
}
```

```javascript
function fibonacci(num) {
    if (num <= 1) return 1;

  return fibonacci(num - 1) + fibonacci(num - 2);
}
```

```
function fibonacci(num: i64): i64 {
  if (num <= 1) return 1
  return fibonacci(num - 1) + fibonacci(num - 2)
}
```


